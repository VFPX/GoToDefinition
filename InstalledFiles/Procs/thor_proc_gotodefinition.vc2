*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="thor_proc_gotodefinition.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS gotodefinition AS basecustom OF "thor_proc_gotodef_base.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "gotodefinition.h"
	*<DefinedPropArrayMethod>
		*m: addmethodwithparameters
		*m: browsetable
		*m: doformaddpem
		*m: getaliasobject
		*m: getallcode
		*m: getallinheritedcode
		*m: getclassfilename
		*m: getcodeorvalue
		*m: getcurrenthighlightedtext
		*m: getentireline
		*m: getinheritedcode
		*m: getobjectparentclasses
		*m: getwindowname
		*m: gogetparentobjectclasses
		*m: gotoclassbyname
		*m: gotodef
		*m: gotodefcreateobject
		*m: gotodefcurlybraces
		*m: gotodeffindclass
		*m: gotodeffindclassinpath
		*m: gotodeffindconstant
		*m: gotodeffindfile
		*m: gotodeffindprocedure
		*m: gotodeffindprogram
		*m: gotodeffindstem
		*m: gotodefineclassparent
		*m: gotodeflocal
		*m: gotodeflocateline
		*m: gotodefnewobject
		*m: gotodefprocessinclude
		*m: gotodefprocessprg
		*m: gotodefprocessprgforclass
		*m: gotodefprocessvcxforclass
		*m: gotoisxclassdefinition
		*m: handleexistingobject
		*m: handlefilenames
		*m: handlekeywords
		*m: handleopenedfilename
		*m: handlethisform
		*m: handlethisinprg
		*m: ismenucode
		*m: ismethodcode
		*m: isprgfile
		*m: isreadonly
		*m: peme_findtopmostparent
		*m: quickaddpem
		*m: readme
		*m: removequotes
		*m: run		&& Occurs when an Active Document is ready to execute your application code.
		*m: setupdodefault
		*m: setupforparentobjectclasses
		*m: showmatchname
		*m: timing
		*p: cfullmethodname
		*p: cmethodname
		*p: csourcefilename
		*p: cstackline
		*p: cwontop
		*p: lclass
		*p: ldodefault
		*p: lformorclass
		*p: lfound
		*p: lfullpath
		*p: lsearched
		*p: nlefthighlightpos
		*p: nrighthighlightpos
		*p: nseconds
		*p: nwindowtype
		*p: oeditorwin
		*p: otopofform
		*a: aproclines[1,0]
		*a: arimings[1,5]
	*</DefinedPropArrayMethod>

	HIDDEN Height,HelpContextID
	cfullmethodname = 
	cmethodname = 
	csourcefilename = 
	cstackline = 
	cwontop = 
	Height = 17
	lclass = .F.
	ldodefault = .F.
	lformorclass = .F.
	lfound = .F.
	lfullpath = .F.
	lsearched = .F.
	Name = "gotodefinition"
	nlefthighlightpos = 0
	nrighthighlightpos = 0
	nseconds = 0
	nwindowtype = 0
	oeditorwin = .NULL.
	oprefs = .NULL.
	otopofform = .NULL.
	Width = 124
	_memberdata = <VFPData>
		<memberdata name="oeditorwin" display="oEditorWin"/>
		<memberdata name="gotodef" display="GoToDef"/>
		<memberdata name="gotodefcreateobject" display="GoToDefCreateObject"/>
		<memberdata name="gotodefcurlybraces" display="GoToDefCurlyBraces"/>
		<memberdata name="gotodeffindclass" display="GoToDefFindClass"/>
		<memberdata name="gotodeffindclassinpath" display="GoToDefFindClassInPath"/>
		<memberdata name="gotodeffindconstant" display="GoToDefFindConstant"/>
		<memberdata name="gotodeffindfile" display="GoToDefFindFile"/>
		<memberdata name="gotodeffindprogram" display="GoToDefFindProgram"/>
		<memberdata name="gotodeflocal" display="GoToDefLocal"/>
		<memberdata name="gotodeflocateline" display="GoToDefLocateLine"/>
		<memberdata name="gotodefnewobject" display="GoToDefNewObject"/>
		<memberdata name="gotodefprocessinclude" display="GoToDefProcessInclude"/>
		<memberdata name="gotodefprocessprg" display="GoToDefProcessPRG"/>
		<memberdata name="gotodefprocessprgforclass" display="GoToDefProcessPRGForClass"/>
		<memberdata name="gotodefprocessvcxforclass" display="GoToDefProcessVCXForClass"/>
		<memberdata name="gotoisxclassdefinition" display="GoToISXClassDefinition"/>
		<memberdata name="getcurrenthighlightedtext" display="GetCurrentHighlightedText"/>
		<memberdata name="movewindow" display="MoveWindow"/>
		<memberdata name="quickaddpem" display="QuickAddPEM"/>
		<memberdata name="removequotes" display="RemoveQuotes"/>
		<memberdata name="nlefthighlightpos" display="nLeftHighlightPos"/>
		<memberdata name="nrighthighlightpos" display="nRightHighlightPos"/>
		<memberdata name="oprefs" display="oPrefs"/>
		<memberdata name="aproclines[1]" display="aProcLines[1]"/>
		<memberdata name="lfound" display="lFound"/>
		<memberdata name="nwindowtype" display="nWindowType"/>
		<memberdata name="lsearched" display="lSearched"/>
		<memberdata name="lformorclass" display="lFormOrClass"/>
		<memberdata name="cmethodname" display="cMethodName"/>
		<memberdata name="cfullmethodname" display="cFullMethodName"/>
		<memberdata name="cwontop" display="cWonTop"/>
		<memberdata name="otopofform" display="oTopOfForm"/>
		<memberdata name="lfullpath" display="lFullPath"/>
		<memberdata name="ldodefault" display="lDoDefault"/>
		<memberdata name="getwindowname" display="GetWindowName"/>
		<memberdata name="setupdodefault" display="SetupDODEFAULT"/>
		<memberdata name="handlethisform" display="HandleTHISFORM"/>
		<memberdata name="handlekeywords" display="HandleKeywords"/>
		<memberdata name="handlefilenames" display="HandleFileNames"/>
		<memberdata name="csourcefilename" display="cSourceFileName"/>
		<memberdata name="lclass" display="lClass"/>
		<memberdata name="peme_findtopmostparent" display="PEME_FindTopmostParent"/>
		<memberdata name="getinheritedcode" display="GetInheritedCode"/>
		<memberdata name="getobjectparentclasses" display="GetObjectParentClasses"/>
		<memberdata name="getclassfilename" display="GetClassFileName"/>
		<memberdata name="setupforparentobjectclasses" display="SetupForParentObjectClasses"/>
		<memberdata name="getcodeorvalue" display="GetCodeOrValue"/>
		<memberdata name="isreadonly" display="IsReadOnly"/>
		<memberdata name="gotodefineclassparent" display="GoToDefineClassParent"/>
		<memberdata name="run" display="Run"/>
		<memberdata name="isprgfile" display="IsPRGFile"/>
		<memberdata name="ismethodcode" display="IsMethodCode"/>
		<memberdata name="ismenucode" display="IsMenuCode"/>
		<memberdata name="handlethisinprg" display="HandleTHISinPRG"/>
		<memberdata name="showmatchname" display="ShowMatchName"/>
		<memberdata name="gotodeffindprocedure" display="GoToDefFindProcedure"/>
		<memberdata name="browsetable" display="BrowseTable"/>
		<memberdata name="handleexistingobject" display="HandleExistingObject"/>
		<memberdata name="addmethodwithparameters" display="AddMethodWithParameters"/>
		<memberdata name="getaliasobject" display="GetAliasObject"/>
		<memberdata name="gotoclassbyname" display="GoToClassByName"/>
		<memberdata name="readme" display="ReadMe"/>
		<memberdata name="arimings[1,5]" display="aRimings[1,5]"/>
		<memberdata name="timing" display="Timing"/>
		<memberdata name="nseconds" display="nSeconds"/>
		<memberdata name="cstackline" display="cStackLine"/>
		<memberdata name="handleopenedfilename" display="HandleOpenedFileName"/>
		<memberdata name="gotodeffindstem" display="GoToDefFindStem"/>
		<memberdata name="getentireline" display="GetEntireLine"/>
		</VFPData>
	
	PROCEDURE addmethodwithparameters
		Local lcMethod, lcMethodName, lcParameters, lcTextAfter, lcTextBefore, lcText, lnEndPos, lnPos
		Local lnStartPos
		
		If Not This.IsMethodCode()
			Return .F.
		Endif
		
		lnStartPos	 = This.oEditorWin.GetLineStart (This.nLeftHighlightPos, 0)
		lcTextBefore = This.oEditorWin.GetString (m.lnStartPos, This.nLeftHighlightPos - 1)
		lcText = Alltrim(m.lcTextBefore + This.cMethodName) 
		
		If ')' # Right(m.lcText, 1)
			Return .F.
		Endif
		
		lnPos = At('(', m.lcText)
		If m.lnPos = 0
			Return .F.
		Endif
		
		lcMethod = Left(m.lcText, m.lnPos - 1)
		If Upper(m.lcMethod) # 'THIS' Or Not '.' $ m.lcMethod
			Return .F.
		Endif
		
		lcMethodName = Justext(m.lcMethod)
		lcParameters = Substr(m.lcText, m.lnPos + 1, Len(m.lcText) - m.lnPos - 1)
		If Not Empty(m.lcParameters)
			lcParameters = 'Lparameters ' + m.lcParameters
		Endif
		
		This.DoFormAddPEM(m.lcMethodName, .T., 'M', .F., m.lcParameters)
		
		Return .T.
		
	ENDPROC

	PROCEDURE browsetable
		Lparameters tcAlias
		
		Execscript(_Screen.cThorDispatcher, 'Thor_Proc_SuperBrowse', m.tcAlias)
		
	ENDPROC

	PROCEDURE Destroy
		This.oEditorWin = Null
		
		
	ENDPROC

	PROCEDURE doformaddpem
		Lparameters lcNewName, llRefreshGrid, lcPEMType, llStayOpen, lcMethodText
		
		Local lcForm
		
		lcForm = Execscript (_Screen.cThorDispatcher, 'Full Path=Thor_Proc_AddPEM.SCX')
		
		Do Form (m.lcForm) With m.lcNewName, m.llRefreshGrid, m.lcPEMType, m.llStayOpen, m.lcMethodText
		
	ENDPROC

	PROCEDURE getaliasobject
		Local lcMethod, lcNewName, lcObject, llSuccess, loObject
		
		llSuccess = .F.
		lcNewName = Execscript (_Screen.cThorDispatcher, 'Thor_Proc_GetThorTableAlias', This.cMethodName)
		If Vartype(m.lcNewName) = 'C'
			loObject = Execscript(_Screen.cThorDispatcher, 'THOR_PROC_ISX_GetNewObject', m.lcNewName)
			If Vartype(m.loObject) = 'O' and PemStatus(loObject, 'Class', 5)
				This.GoToClassByName(@m.loObject)
				Return .T.
			Endif
		Endif
		
		If '.' $ This.cMethodName
			lcObject  = Juststem(This.cMethodName)
			lcMethod  = Justext(This.cMethodName)
			lcNewName = Execscript (_Screen.cThorDispatcher, 'Thor_Proc_GetThorTableAlias', m.lcObject)
			If Vartype(m.lcNewName) = 'C'
				loObject = Execscript(_Screen.cThorDispatcher, 'THOR_PROC_ISX_GetNewObject', m.lcNewName)
				If Vartype(m.loObject) = 'O' and PemStatus(loObject, 'Class', 5)
					This.GoToClassByName(@m.loObject, m.lcMethod)
					Return .T.
				Endif
			Endif
		Endif
		
		Return m.llSuccess
		
	ENDPROC

	PROCEDURE getallcode
		Lparameters loObject, lcMethodName, lcNamePrefix, tbParentage, tlDefaultOnly
		
		Local lcCode, lcHeaderText, lcInheritedCode, lcResult, lcText 
		
		lcResult = ''
		
		If This.GetPEMStatus (loObject, lcMethodName, 0)
		
			lcCode = loObject.ReadMethod (lcMethodName)
			If tbParentage
				lcInheritedCode = This.GetAllInheritedCode(lcMethodName, loObject, lcNamePrefix)
			Else
				lcInheritedCode = ''
			Endif
		
			If Not (Empty(lcCode) And Empty(lcInheritedCode))
				If (Not Empty (lcCode)) and not tlDefaultOnly
					lcText = 'Procedure ' + Evl(lcNamePrefix, '') + '.' + lcMethodName + ccCRLF		;
						+ lcCode + ccCRLF										;
						+ 'EndProc' + ccCRLF
					lcResult = lcResult + lcText
				Endif
		
				If Not Empty(lcInheritedCode)
					lcResult = lcResult + Iif(Empty(lcCode), '', ccCRLF) + lcInheritedCode
				Endif
			Endif
		Endif
		
		Return lcResult
		
	ENDPROC

	PROCEDURE getallinheritedcode
		Lparameters lcName, loParent, lcNamePrefix
		
		Local  ;
			loParentInfo As Object	,;
			loParentMethods As Object
		Local lcResult, lcText, llQuote, lnI
		
		lcResult = ''
		loParentMethods = This.GetObjectParentClasses (lcName, 'Code', loParent)
		For lnI = 1 To loParentMethods.Count
			loParentInfo = loParentMethods.Item (lnI)
			If loParentInfo.NonDefault
				llQuote = Iif (' ' $ loParentInfo.VCX, ['], '')
				lcText = ccTopDividerLine 						;
					+ '* Class  ' + loParentInfo.Class + ' of ' + llQuote + loParentInfo.VCX + llQuote + ccCRLF ;
					+ Iif (Empty (loParentInfo.Class # loParentInfo.Name), '', '* Object ' + loParentInfo.Name + ccCRLF) ;
					+ 'Procedure ' + lcNamePrefix + '::' + loParentInfo.Name + '.' + Trim (lcName) + ccCRLF + loParentInfo.Code + ccCRLF ;
					+ 'EndProc' + ccCRLF
				lcResult = lcResult + lcText
			Endif
		Endfor
		
		Return lcResult
		
	ENDPROC

	PROCEDURE getclassfilename
		Lparameters tcClassLoc, tcPath
		
		*** JRN 02/24/2009 : per Doug ... handles cases of absolute paths and relative to current directory
		
		Do Case
			Case ':' $ tcClassLoc
				Return tcClassLoc
		
			Case File ( Fullpath ( m.tcClassLoc, m.tcPath ) )
				Return Fullpath (tcClassLoc, tcPath)
		
			Otherwise
				Return Fullpath ( m.tcClassLoc )
		Endcase
		
	ENDPROC

	PROCEDURE getcodeorvalue
		Lparameters lcStyle, lcSearchName, loClassDef
		
		Local lcMethodCode, lcPropertyValue, lnPos
		Do Case
		
			Case Empty (lcStyle)
		
			Case lcStyle = 'Code'
				lcMethodCode = Strextract (ccLF + Methods, ccLF + 'procedure ' + lcSearchName + ccCRLF, ccCRLF + 'endproc', 1, 1)
				If Empty (lcMethodCode)
					AddProperty (loClassDef, 'NonDefault', .F.)
				Else
					AddProperty (loClassDef, 'Code', lcMethodCode )
					AddProperty (loClassDef, 'NonDefault', .T.)
				Endif
		
			Case lcStyle = 'Value'
				lnPos = Atc (ccLF + lcSearchName + ' = ', ccLF + properties)
				If lnPos > 0
					lcPropertyValue	 = Substr (properties, lnPos ) && + Len(lcSearchName) + 3)
					AddProperty (loClassDef, 'Value', This.ExtractPropertyValue (lcSearchName, lcPropertyValue))
					AddProperty (loClassDef, 'NonDefault', .T.)
				Else
					AddProperty (loClassDef, 'NonDefault', .F.)
				Endif
		
		Endcase
		
		Return
		
	ENDPROC

	PROCEDURE getcurrenthighlightedtext
		Lparameters llFullObjectName, llSavePositions
		
		*** JRN 10/16/2010 : llFullObjectName captures full reference,
		*   meaning including dots and handling of WITH/ENDWITH
		
		Local lcChar, lcPreviousCode, lcResult, lnNewRow, lnPosition, lnSelEnd, lnSelStart, lnWindowType
		Local cContainer, nLineCount
		
		lnWindowType = This.oEditorWin.FindWindow()
		If 0 > m.lnWindowType
			Return ''
		Endif
		
		lnSelStart = This.oEditorWin.GetSelStart()
		lnSelEnd   = This.oEditorWin.GetSelEnd()
		
		If m.llSavePositions And (This.IsPRGFile() Or This.IsMethodCode() Or This.IsMenuCode())
			If Pemstatus(_Screen, 'aGoToDefBookmark', 5) = .F.
				_Screen.AddProperty('aGoToDefBookmark[1, 4]')
			Endif
			lnNewRow = Alen(_Screen.aGoToDefBookmark, 1) + 1
			Dimension _Screen.aGoToDefBookmark[m.lnNewRow, 4]
			_Screen.aGoToDefBookmark[m.lnNewRow, 1] = This.oEditorWin.GetTitle()
			_Screen.aGoToDefBookmark[m.lnNewRow, 2] = This.oEditorWin.GetWindowHandle()
			_Screen.aGoToDefBookmark[m.lnNewRow, 3] = m.lnSelStart
			_Screen.aGoToDefBookmark[m.lnNewRow, 4] = m.lnSelEnd
		Else
			lnNewRow = 1 && A LIE!  but simplifies capture of Start/end text later
		Endif
		
		****************************************************************
		*** JRN 2010-04-04 : remainder of this code specific to extracting the full object path,
		*   removing extra chars, etc
		If m.lnSelStart < m.lnSelEnd && any highlighted text?
		
			lcResult = This.oEditorWin.GetString (m.lnSelStart, m.lnSelEnd - 1)
		
			If Not Empty(This.RemoveQuotes(m.lcResult))
				This.nLeftHighlightPos	= m.lnSelStart
				This.nRightHighlightPos	= m.lnSelEnd
				If m.llSavePositions And (This.IsPRGFile() Or This.IsMethodCode() Or This.IsMenuCode())
					_Screen.aGoToDefBookmark[m.lnNewRow, 3] = m.lnSelStart
					_Screen.aGoToDefBookmark[m.lnNewRow, 4] = m.lnSelEnd
				Endif
				Return ['] + Substr(lcResult, 2, Len(lcResult) - 2) + [']
			Endif
		
			* remove trailing garbage characters
			If '(' $ m.lcResult && first, anything after a (
				lnSelEnd = m.lnSelStart + At ('(', m.lcResult) - 1
				lcResult = This.oEditorWin.GetString (m.lnSelStart, m.lnSelEnd - 1)
			Endif
		
			*!* ******************** Removed 11/18/2014 *****************
			*!* lnSelStart = lnSelEnd
			*!* Do While Not This.IsNameChar (Right (lcResult, 1))
			*!* 	If Empty (lcResult)
			*!* 		Return ''
			*!* 	Else
			*!* 		lcResult   = Left (lcResult, Len (lcResult) - 1)
			*!* 		lnSelStart = lnSelStart - 1
			*!* 	Endif
			*!* Enddo
		
			This.nRightHighlightPos	= m.lnSelEnd - 1
			*!* lcResult = '' && because we march to the left from here ...
		
		Else &&  JRN 2010-04-02  no highlighted text ... add characters to right
			lcResult = ''
		
			lnPosition = m.lnSelStart
			Do While .T.
				lcChar = This.oEditorWin.GetCharacter (m.lnPosition)
				If This.IsNameChar (m.lcChar)
					lcResult   = m.lcResult + m.lcChar
					lnPosition = m.lnPosition + 1
				Else
					Exit
				Endif
			Enddo
		
			This.nRightHighlightPos	= m.lnPosition - 1
		
		Endif
		
		*** JRN 2010-04-02 : add in preceding characters
		For lnPosition = m.lnSelStart - 1 To 0 Step - 1
			lcChar = This.oEditorWin.GetCharacter (m.lnPosition)
			If This.IsNameChar (m.lcChar) Or m.lcChar = '.'
				lcResult = m.lcChar + m.lcResult
			Else
				Exit
			Endif
		Endfor
		
		This.nLeftHighlightPos	= m.lnPosition + 1
		
		If m.llFullObjectName
		
			*!* ******************** Removed 11/18/2014 *****************
			*!* *** JRN 2010-04-04 : get rid of macro substitutions
			*!* If '..' $ lcResult
			*!* 	lcResult = Substr (lcResult, Rat ('.', lcResult) + 1)
			*!* Endif
		
			* Need to look backwards for WITH ???
			If Left (m.lcResult + '.', 1) = '.'			;
					And This.nWindowType > 0			;
					And Not Inlist(Upper(m.lcResult), '.T.', '.F.')
		
				lcPreviousCode = This.oEditorWin.GetString (0, m.lnSelEnd - 1)
				nLineCount	   = Alines (This.aProcLines, m.lcPreviousCode + ' ') && ensure trailing line
				If m.nLineCount > 1
					cContainer = This.FindWith (m.nLineCount)
					lcResult   = m.cContainer + m.lcResult
				Endif
			Endif
		Endif
		
		If m.llSavePositions And (This.IsPRGFile() Or This.IsMethodCode() Or This.IsMenuCode())
			_Screen.aGoToDefBookmark[m.lnNewRow, 3] = This.nLeftHighlightPos
			_Screen.aGoToDefBookmark[m.lnNewRow, 4] = Max(This.nRightHighlightPos + 1, This.nLeftHighlightPos + 3)
		Endif
		Return m.lcResult
		
	ENDPROC

	PROCEDURE getentireline
		Lparameters lnPos
		
		Local lnEndPos, lnStartPos
		
		lnStartPos = This.oEditorWin.GetLineStart(m.lnPos, 0)
		lnEndPos   = This.oEditorWin.GetLineStart(m.lnPos, 1)
		
		Return This.oEditorWin.GetString(m.lnStartPos, m.lnEndPos)
	ENDPROC

	PROCEDURE getinheritedcode
		Lparameters lcPem, loObject, llAllLevels
		
		Local lnI, loParents
		loParents = This.GetObjectParentClasses (lcPem, 'Code', loObject)
		
		For lnI = 1 To Min(loParents.Count, IIf (llAllLevels, 1000, 1))
			If loParents (lnI).NonDefault
				Return loParents (lnI).Code
			Endif
		Endfor
		
		Return ''
		
		
		
		
	ENDPROC

	PROCEDURE getobjectparentclasses
		Lparameters tcPem, tcStyle, toObject
		
		* Returns a collection of all the parent classes for an object
		
		* Each element in the collection is an object with these properties:
		*     Class -- the name of the class
		*     VCX   -- the name of the class library
		*     Name  -- the name of the object relative to the class
		*                empty except for those objects that are member objects in the class
		*                such as a label or textbox within a contain class
		*
		
		* Parameters (all are optional)
		* tcPem:          the name of a pem (case-insensitive) for which non-default
		*                 code or properties are requested.  If non-empty. a property
		*                 named 'NonDefault' is included in the result
		* lcStyle:
		*     	'Code'    includes another property named 'Code' with any non-default code
		*		'Value'   includes another property named 'Property' with any non-default values
		*
		* toObject:  the object for which this is requested.  If not supplied,
		*            the currently selected object is used
		
		Local loClassCollection As 'Collection'
		Local laObjects[1], lcClass, lcClassLib, lcFileName, lcParent, lcPem, lcResult, lcStyle, lnSelect
		Local loDetailInfo, loObject, loSetupInfo, loTopofForm
		
		loClassCollection = Createobject ('Collection')
		
		lcPem	= Evl (tcPem, '')
		lcStyle	= Evl (tcStyle, 'None')
		
		Do Case
			Case 'O' = Vartype (toObject)
				loObject = toObject
			Case 0 # Aselobj (laObjects) Or 0 # Aselobj (laObjects, 1)
				loObject = laObjects(1)
			Otherwise
				Return loClassCollection
		Endcase
		
		lnSelect = Select()
		Select 0
		
		If Empty (lcPem) Or			;
				(This.GetPEMStatus (loObject, lcPem, 5) And This.GetPEMStatus (loObject, lcPem, 6))
		
			loTopofForm = This.FindTopMostParent()
			If This.lClass And loTopofForm = loObject
		
				Use (This.cSourceFileName) Again Shared Alias VCX
				Locate For Lower (OBJNAME) == Lower (loObject.Class) And Lower (RESERVED1) = 'class'
		
				If Found()
					lcClass     = VCX.Class
					lcBaseClass = VCX.BaseClass
					If Not Empty (VCX.ClassLoc)
						lcClassLib = This.GetClassFileName (VCX.ClassLoc, Addbs (JustPath(This.cSourceFileName))) 
					Else
						lcClassLib = ''
					Endif
				Else
					lcClass	    = ''
					lcClassLib  = ''
					lcBaseClass = ''
				Endif
				lcParent = ''
				Use
		
			Else
				lcFileName	= loObject.ClassLibrary
				loSetupInfo	= This.SetupForParentObjectClasses (Lower (loObject.Class), lcFileName, loObject, loTopofForm)
		
				With loSetupInfo
					lcClass	    = .Class
					lcClassLib  = .Classlib
					lcParent    = .Parent
					lcBaseClass = .BaseClass
				Endwith
			Endif
		
			loDetailInfo = This.GoGetParentObjectClasses (loClassCollection, lcClass, lcClassLib, lcParent, loObject.Name, lcStyle, lcPem, lcBaseClass)
			With loDetailInfo
				lcClass	    = .Class
				lcClassLib  = .Classlib
				lcParent    = .Parent
				lcBaseClass = .BaseClass
			Endwith
		
			*** JRN 12/26/2008 : Handling of members (pages, optionbuttons, etc)
			Do Case
				Case loTopofForm = loObject && nothing to do
		
				Case Lower (lcClass) == Lower (loObject.BaseClass) && nothing here either
		
				Case This.GetPEMStatus (loObject.Parent, 'MemberClass', 5)
					loDetailInfo = This.GoGetParentObjectClasses (loClassCollection, loObject.Parent.MemberClass, loObject.Parent.MemberClassLibrary, '', loObject.Name, lcStyle, lcPem, lcBaseClass)
					With loDetailInfo
						lcClass	    = .Class
						lcClassLib  = .Classlib
						lcParent    = .Parent
						lcBaseClass = .BaseClass
					Endwith
		
				Case This.GetPEMStatus (loObject.Parent, 'HeaderClass', 5)
					loDetailInfo = This.GoGetParentObjectClasses (loClassCollection, loObject.Parent.HeaderClass, loObject.Parent.HeaderClassLibrary, '', loObject.Name, lcStyle, lcPem, lcBaseClass)
					With loDetailInfo
						lcClass	    = .Class
						lcClassLib  = .Classlib
						lcParent    = .Parent
						lcBaseClass = .BaseClass
					Endwith
		
			Endcase
		
		Endif
		
		Select (lnSelect)
		Return loClassCollection
		
		
		
	ENDPROC

	PROCEDURE getwindowname
		#Define ccInherited 'Inherited '
		*** JRN 2010-04-03 : get name of window on top; correcting as well for reference to top of form/class
		This.cWonTop = Alltrim(Chrtran(Upper(This.cWonTop), '*', ' '))
		Do Case
				* remove timestamp, if any
			Case '(' $ This.cWonTop
				This.cWonTop   = Left(This.cWonTop, At('(', This.cWonTop) - 1)
				This.lFullPath = .T.
				* for inherited code
			Case Atc(ccInherited, This.cWonTop) = 2
				*	this.cWonTop   = Left(this.cWonTop, rAt('._', this.cWonTop) - 1)
		
				*** JRN 2023-01-28 : Eliminate prefix
				This.cWonTop	  = Strtran(This.cWonTop, ccInherited, '', 1, 1, 1)
				*** JRN 2023-01-28 : And the  random suffix
				This.cWonTop	  = Left(This.cWonTop, Rat('_', This.cWonTop) - 1)
				This.lFullPath	  = .T.
				This.lFormOrClass = .T.
		Endcase
		
		If (Not Isnull(This.oTopOfForm)) And This.cWonTop = Upper(This.oTopOfForm.Name) + '.'
			This.cWonTop = Substr(This.cWonTop, At('.', This.cWonTop))
		Endif
		This.cWonTop = Alltrim(Chrtran(This.cWonTop, '-', ''))
		
	ENDPROC

	PROCEDURE gogetparentobjectclasses
		Lparameters loCollection, lcClass, lcClassLib, lcParent, lcObjectName, lcStyle, lcPEM, lcBaseClass
		
		Local loClassDef AS 'Empty'
		Local loException AS Object
		Local loResult AS 'Empty'
		Local lbFileOpened, lcCurrentParent, lcMethodCode, lcObjectPathName, lcParent2, lcResult, lcSearchName
		Local lcTempObject, lcUseTable, lnRecno 
		
		lcResult = ''
		Select 0
		
		* This apparently awkward construction chosen to avoid conflicts where the name
		* of the VCX is the same as the name of a VCX used by PEM Editor
		
		Text to lcUseTable NoShow
		Lparameters lcTable
		Use (lcTable)Again Shared Alias VCX
		EndText 
		
		Do While Not Empty (lcClassLib)
		
			loClassDef = Createobject ('Empty')
			AddProperty (loClassDef, 'Class', lcClass)
			AddProperty (loClassDef, 'BaseClass', lcBaseClass)
			AddProperty (loClassDef, 'VCX', lcClassLib)
			AddProperty (loClassDef, 'ErrorMsg', '')
			AddProperty (loClassDef, 'Name', lcClass)
			AddProperty (loClassDef, 'NonDefault', .F.)
		
			Try
				ExecScript(lcUseTable, lcClassLib)
				lbFileOpened = .T.
			Catch To loException
				lbFileOpened = .F.
				lcResult = lcResult	+ ccBottomDividerLine												;
					+ Strtran (ccLOC_ViewParentCode_File_Failed, '<FileName>', "'" + lcClassLib + "'")	;
					+ ccCRLF + loException.Message														;
					+ ccCRLF + ccCRLF
				lcClassLib			= '' && all done, can't even open file
				loClassDef.ErrorMsg	= lcResult 
			Endtry
		
			If lbFileOpened
				lcSearchName = Lower (lcPEM)
				If Empty (lcParent) && simple case ... this object defined here
					lcObjectPathName = lcClass
					Locate For Lower (OBJNAME) == lcClass And Lower (RESERVED1) = 'class'
					This.GetCodeOrValue (lcStyle, lcSearchName, loClassDef)
					lcBaseClass = VCX.BaseClass
		
				Else && this object inherited as object in parent class
		
					* (1)  have to back up through parentage to see where this object is defined in the class
					* (2)  for some objects, the method code may be saved farther back!
					lcObjectPathName = lcParent + '.' + lcObjectName
					lnRecno			 = 0
					lcTempObject	 = Lower (lcObjectPathName)
					lcCurrentParent	 = lcParent
					lcMethodCode	 = ''
					loClassDef.Class = GetWordNum(lcObjectPathName, 1, '.')
					loClassDef.Name  = lcObjectPathName
					Do While Not Empty (lcTempObject) And Empty (lcMethodCode)
						Locate For lcTempObject == Lower ( IIf (Empty (Parent), '', Parent + '.') + OBJNAME) ;
							And (Lower (RESERVED1) # 'class' Or Not '.' $ lcTempObject)
						If Found() And (lnRecno = 0 Or Inlist (Lower (BaseClass), 'pageframe', 'grid'))
							lcParent2 = Substr (lcCurrentParent, 2 + Len ( lcTempObject))
							If lnRecno = 0
								lnRecno = Recno()
								Do Case
									Case Len ( lcTempObject) > Len (lcCurrentParent)
										lcParent	 = ''
										lcSearchName = lcPEM
									Case Empty (lcParent2)
										lcParent	 = VCX.Class
										lcSearchName = lcObjectName + '.' + lcPEM
									Otherwise
										lcParent	 = VCX.Class + '.' + lcParent2
										lcSearchName = lcParent2 + '.' + lcObjectName + '.' + lcPEM
								Endcase
							Endif
							This.GetCodeOrValue (lcStyle, lcSearchName, loClassDef)
						Endif
		
						If '.' $ lcTempObject
							lcTempObject = Juststem (lcTempObject)
						Else
							lcTempObject = ''
						Endif
		
					Enddo
		
					If lnRecno # 0
						Goto (lnRecno)
					Endif
		
				Endif
		
				If Found()
					lcClass     = VCX.Class
					lcBaseClass = VCX.BaseClass
					Do Case
						Case lcStyle = 'Code' And (ccCRLF + '*' + Lower (lcPEM) + ' ') $ ccCRLF + Reserved3
							lcClassLib = .F. && custom in this class; don't go any further
						Case lcStyle = 'Value' And (ccCRLF + Lower (lcPEM) + ' ' ) $ ccCRLF + Strtran (Reserved3, ccCRLF, ' ' + ccCRLF)
							lcClassLib = .F. && custom in this class; don't go any further
						Case Empty (VCX.ClassLoc)
							lcClassLib = .F. && baseclass
						Otherwise
							*** DougHennig 12/06/2008: VCX.ClassLoc is relative to the open class library
							lcClassLib = This.GetClassFileName (VCX.ClassLoc, Addbs (Justpath (lcClassLib)))
					Endcase
		
				Else
					lcResult = lcResult	+ ccBottomDividerLine											;
						+ Strtran (Strtran (ccLOC_ViewParentCode_Class_Failed, '<FileName>', "'" + lcClassLib + "'"), '<ClassName>', lcObjectPathName ) ;
						+ ccCRLF + ccCRLF
					loClassDef.ErrorMsg	= lcResult
					lcClassLib			= ''
				Endif
		
			Endif
		
			loCollection.Add (loClassDef)
			Use
		
		Enddo
		
		Use In (Select ('VCX'))
		
		loResult = Createobject ('Empty')
		AddProperty (loResult, 'Result', 	loClassDef)
		AddProperty (loResult, 'Class', 	lcClass)
		AddProperty (loResult, 'BaseClass', lcBaseClass)
		AddProperty (loResult, 'ClassLib', 	lcClassLib)
		AddProperty (loResult, 'Parent', 	lcParent)
		
		Return loResult
		
	ENDPROC

	PROCEDURE gotoclassbyname
		Lparameters loObject, lcMethod
		
		Local lcBlock, lcClass, lcClassLib, lcCode, lcDefineClass, lcExt, lcPRG, lcQuote, lnEnd, lnI
		Local lnStart, loBlock, loCodeBlocks
		
		lcClass	   = m.loObject.Class
		lcClassLib = m.loObject.ClassLibrary
		lcMethod   = Evl(m.lcMethod, '')
		
		* These both are necessary else there is hanging reference preventing opening the file
		loObject			= Null
		_Screen.xThorResult	= Null
		
		lcExt	 = Upper(Justext(m.lcClassLib))
		
		Do Case
			Case Empty(m.lcClass)
				Return .F.
		
			Case m.lcExt == 'VCX'
				This.EditSourceX(m.lcClassLib, m.lcClass, m.lcMethod)
		
			Case m.lcExt == 'PRG' Or m.lcExt == 'FXP'
		
				Do While .T.
					lcPRG		 = Forceext(m.lcClassLib, 'PRG')
					If Not File(m.lcPRG)
						Return .F.
					Endif
		
					lcCode		  = Filetostr(m.lcPRG)
					loCodeBlocks  = Execscript (_Screen.cThorDispatcher, 'Thor_Proc_GetProcedureStartPositions.prg', m.lcCode, .T.)
					lcDefineClass = ''
		
					For lnI = 1 To m.loCodeBlocks.Count
						loBlock	  = m.loCodeBlocks.Item[m.lnI]
						Do Case
							Case Upper(m.loBlock.Name) == Upper(m.lcClass)
								lcDefineClass = Substr (m.lcCode, m.loBlock.Start, m.loBlock.Length)
								lnStart		  = m.loBlock.Start + Atc(m.lcClass, m.lcDefineClass) - 1
								lnEnd		  = m.lnStart + Len(m.lcClass)
		
								If Empty(m.lcMethod)
									This.EditSourceX(m.lcPRG, , , m.lnStart, m.lnEnd)
									Execscript(_Screen.cThorDispatcher, 'Thor_Proc_SelectText')
									Return .T.
								Endif
		
							Case Upper(m.loBlock.Name) == Upper(m.lcClass + '.' + m.lcMethod)
								lcBlock	= Substr (m.lcCode, m.loBlock.Start, m.loBlock.Length)
								lnStart	= m.loBlock.Start + Atc(m.lcMethod, m.lcBlock) - 1
								lnEnd	= m.lnStart + Len(m.lcMethod)
		
								This.EditSourceX(m.lcPRG, , , m.lnStart, m.lnEnd)
								Execscript(_Screen.cThorDispatcher, 'Thor_Proc_SelectText')
		
								Return .T.
		
						Endcase
					Endfor
		
					* -------------------------------------------------------------------------------- 
					* OK, let's try the parent class
					If Empty(m.lcDefineClass)
						Return .F.
					Endif
		
					lcClass	   = Chrtran(Getwordnum(m.lcDefineClass, 5), ['"] + '[]', '')
					lcClass	   = Chrtran(m.lcClass, CRLF, '')
					lcClassLib = ''
					If Upper(Getwordnum(m.lcDefineClass, 6)) == 'OF'
						lcClassLib = Getwordnum(m.lcDefineClass, 7)
						lcClassLib = Chrtran(m.lcClassLib, CRLF, '')
						lcQuote	   = Left(m.lcClassLib, 1)
						If m.lcQuote $  ['"] + '['
							lcClassLib = Substr(m.lcDefineClass, Atc(m.lcClassLib, m.lcDefineClass))
							lcClassLib = Strextract(m.lcClassLib, m.lcQuote, Chrtran(m.lcQuote, '[', ']'))
						Endif
					Endif
		
					Try
						loObject = Newobject(m.lcClass, m.lcClassLib, 0)
					Catch
					Endtry
		
					If Isnull(m.loObject)
						Return .F.
					Endif
		
					lcClassLib = m.loObject.ClassLibrary
					loObject   = Null
		
				Enddo
		
				Return .F.
		
		Endcase
	ENDPROC

	PROCEDURE gotodef
		Lparameters loObject, lcObjectName, lcMethodName, loTopOfForm, llDoDefault
		
		Local loChild As Object
		Local loPEMEditor As Object
		Local loTarget As Object
		Local lcPossibleObject, lcTarget, lnControlCount, lnHeight, lnI, lnLeft, lnTop, lnWidth, loEditorWin
		
		lcTarget	= 'loObject' + lcObjectName
		loPEMEditor	= This.oPEMEditor
		
		If 'O' = Type (lcTarget)
			loTarget		 = Evaluate (lcTarget)
			lcPossibleObject = 'loTarget' + Iif(Empty(lcMethodName), '', '.' + lcMethodName)
		
			Do Case
					* Object
				Case 'O' = Type (lcPossibleObject)
					If Not Isnull (loPEMEditor)
						loPEMEditor.SetCurrentSelectedObject (Evaluate (lcPossibleObject))
					Else
						This.FocusOnControl(Evaluate (lcPossibleObject))
					Endif
					Return .T.
		
					* not a PEM
				Case Not This.GetPEMStatus (loTarget, lcMethodName, 5)
		
					* Property
				Case This.GetPEMStatus (loTarget, lcMethodName, 3) = 'Property'
					If Not Isnull (loPEMEditor)
						loPEMEditor.SetCurrentObjectProperty (loTarget, lcMethodName)
					Endif
					Return .T.
		
					* not a method or event
				Case Not Inlist (This.GetPEMStatus (loTarget, lcMethodName, 3), 'Method', 'Event')
		
					* no code, or only wanting to show parent code
				Case llDoDefault
					This.ViewParentCode (lcMethodName, loTarget, .T., llDoDefault)
					This.MoveWindow()
					Return .T.
		
					* show code
				Otherwise
					This.EditLocalMethodCode (This.cSourceFileName, loTopOfForm, loTarget, lcMethodName, This.lClass)
					This.MoveWindow()
		
					If Empty (loTarget.ReadMethod (lcMethodName))					;
							And This.GetPEMStatus (loTarget, lcMethodName, 6)		;
							And This.GetPEMStatus (loTarget, lcMethodName, 0)
		
						* find the editor window just opened (is default)
						loEditorWin = This.oEditorWin
						loEditorWin.FindWindow()
						lnLeft	 = loEditorWin.GetLeft()
						lnTop	 = loEditorWin.GetTop()
						lnWidth	 = loEditorWin.GetWidth()
						lnHeight = loEditorWin.GetHeight()
		
						This.ViewParentCode (lcMethodName, loTarget, .T., llDoDefault)
		
						* and move the parent code window below it
						loEditorWin.FindWindow()
						loEditorWin.MoveWindow (lnLeft + 30, lnTop + 60)
						loEditorWin.ReSizeWindow (lnWidth - 20, Max(lnHeight - 60, 100))
		
					Endif
					Return .T.
		
					*!* * Removed 4/7/2013 / JRN
					*!* * no code, or only wanting to show parent code
					*!* 		Case llDoDefault Or (								;
					*!* 	Empty (loTarget.ReadMethod (lcMethodName))				;
					*!* 	And This.GetPEMStatus (loTarget, lcMethodName, 6)		;
					*!* 	And This.GetPEMStatus (loTarget, lcMethodName, 0)		;
					*!* 	)
					*!* This.ViewParentCode (lcMethodName, loTarget, .T., llDoDefault)
					*!* This.MoveWindow()
					*!* Return .T.
		
					*!* * show code
					*!* 		Otherwise
					*!* This.EditLocalMethodCode (This.cSourceFileName, loTopOfForm, loTarget, lcMethodName, This.lClass)
					*!* This.MoveWindow()
					*!* Return .T.
		
			Endcase
		
		Endif
		
		lnControlCount = This.GetControlCount (loObject)
		If lnControlCount # 0 And 'O' = Type ('loObject.Objects(1)')
		
			For lnI = 1 To lnControlCount
				loChild = loObject.Objects (lnI)
				If This.GoToDef (loChild, lcObjectName, lcMethodName, loTopOfForm, llDoDefault)
					Return .T.
				Endif
			Endfor
		
		Endif
		
		Return .F.
		
	ENDPROC

	PROCEDURE gotodefcreateobject
		Local lcClass, lcText, lnEndPos
		
		lnEndPos = This.oEditorWin.GetLineStart (This.nRightHighlightPos, 1)
		lcText	 = This.oEditorWin.GetString (This.nRightHighlightPos + 1, lnEndPos)
		
		If '(' $ lcText
			lcText = Substr (lcText, 1 + At ('(', lcText))
		Endif
		
		If ')' $ lcText
			lcText = Left (lcText, At (')', lcText) - 1)
		Endif
		
		If Alines (laLines, lcText, .T., ',', ';') >= 1
			lcClass	   = This.RemoveQuotes (Alltrim (laLines(1)))
			Return This.GoToDefFindClass (lcClass)
		Else
			Return .F.
		Endif
		
	ENDPROC

	PROCEDURE gotodefcurlybraces
		Lparameters lcMethodName
		
		Local laWords[1], lcCLass, lcClassLib, lcCommand, lcDoubles, lcFullName, lcQuote, lnEndPos
		Local lnStartPos, lnWordCount
		
		lcCommand = This.GetEntireLine(This.nRightHighlightPos)
		
		lcDoubles = Strextract(m.lcCommand, '{{', '}}')
		If Empty(m.lcDoubles) Or Not Upper(Getwordnum(m.lcDoubles, 1, ' =' + Tab)) == Upper(m.lcMethodName)
			Return .F.
		Endif
		
		lnWordCount	= Alines(laWords, Strextract(m.lcDoubles, '{', '}'), 5, ',')
		lcCLass		= m.laWords[1]
		lcClassLib	= ''
		
		If m.lnWordCount > 1
			lcClassLib = m.laWords[2]
			lcQuote	   = Left(m.lcClassLib, 1)
			If m.lcQuote $  ['"] + '['
				lcClassLib = Substr(m.lcCommand, Atc(m.lcClassLib, m.lcCommand))
				lcClassLib = Strextract(m.lcClassLib, m.lcQuote, Chrtran(m.lcQuote, '[', ']'))
			Endif
			lcFullName = Fullpath (m.lcClassLib)
			If File (m.lcFullName)
				This.EditSourceX (m.lcFullName, m.lcCLass)
				Return .T.
			Else
				Return .F.
			Endif
		
		Else
			Return This.GoToDefFindClass (m.lcCLass)
		Endif
		
	ENDPROC

	PROCEDURE gotodeffindclass
		Lparameters tcName
		
		Local loInclude AS 'Empty'
		Local lcFileName, lcMethodCode, lcName, llFound, lnCharPosition 
		* Create an object to hold return values.
		
		loInclude = Createobject ('Empty')
		AddProperty (loInclude, 'File', '')
		AddProperty (loInclude, 'CharPosition', 0)
		
		lcName		 = Upper (tcName)
		
		* This a PRG?  
		If loInclude.CharPosition = 0 and This.IsPRGFile()
			lcMethodCode = Upper (This.oEditorWin.Getstring(0, 10000000))
			This.GoToDefProcessPRGForClass ('', lcName, loInclude, lcMethodCode)
		Endif
		
		If loInclude.CharPosition = 0
			This.GoToDefFindClassInPath (lcName, loInclude)
		Endif
		
		lcFileName	   = loInclude.File
		lnCharPosition = loInclude.CharPosition
		
		Do Case
		
			Case Empty (lcFileName) And Empty (lnCharPosition)
				llFound = .F.
		
			Case Empty (lcFileName)
				llFound = .T.
				With This.oEditorWin
					.Select (lnCharPosition -1, lnCharPosition + Len (lcName) - 1)
					.ShowPosition()
				Endwith
		
			Case Empty (lnCharPosition)
				llFound = .T.
				This.EditsourceX (lcFileName, tcName)
		
			Otherwise
				llFound = .T.
				This.EditsourceX (lcFileName, , ,lnCharPosition, lnCharPosition + Len (lcName))
				ExecScript(_Screen.cThorDispatcher, 'THOR_PROC_SelectText', lnCharPosition - 1, lnCharPosition + Len (lcName) - 1)
		Endcase
		
		Return llFound
		
	ENDPROC

	PROCEDURE gotodeffindclassinpath
		Lparameters tcName, toInclude
		
		Local laLines[1], lcPRG, lcProcedures, lcVCX, llFound, lnI, lnLines, loFile
		
		* Check all open class libraries.
		
		If Not llFound
			lcProcedures = Set ('ClassLib')
			lcProcedures = Chrtran (m.lcProcedures, ['"], [ ])
			lnLines		 = Alines (laLines, m.lcProcedures, 5, ',')
			For lnI = 1 To lnLines
				If Not Empty (laLines[lnI])
					lcVCX = Alltrim (laLines[lnI])
					Do Case
						Case '"' $ lcVCX
							lcVCX = Substr (lcVCX, 2, At ('"', lcVCX, 2) - 2)
						Case ' ALIAS ' $ Upper (lcVCX)
							lcVCX = Left (lcVCX, At (' ALIAS ', lcVCX) - 1)
					Endcase
		
					If Inlist (Upper (Justext (laLines[lnI])), 'VCX')
						If File (lcVCX)
							This.GoToDefProcessVCXForClass (lcVCX, tcName, toInclude)
							If Not Empty (toInclude.File)
								Exit
							Endif Not Empty (toInclude.File)
						Endif
					Endif
				Endif
			Next lnI
		Endif Not llFound
		
		
		* Check all open procedure files.
		
		If Not llFound
			lcProcedures = Set ('Procedure')
			lcProcedures = Chrtran (m.lcProcedures, ['"], [ ])
			lnLines		 = Alines (laLines, m.lcProcedures, 5, ',')
			For lnI = 1 To lnLines
				If Not Empty (laLines[lnI])
					If Inlist (Upper (Justext (laLines[lnI])), 'PRG', 'FXP')
						lcPRG = Forceext (laLines[lnI], 'PRG')
						If File (lcPRG)
							This.GoToDefProcessPRGForClass (lcPRG, tcName, toInclude, Upper (Filetostr (lcPRG)))
							If Not Empty (toInclude.File)
								Exit
							Endif Not Empty (toInclude.File)
						Endif
					Endif
				Endif
			Next lnI
		Endif Not llFound
		
		
		* Check all VCXs in the active project.
		
		If Not llFound And Type ('_vfp.ActiveProject') = 'O'
			For Each loFile In _vfp.ActiveProject.Files
				If Not llFound And loFile.Type = 'V'
					This.GoToDefProcessVCXForClass (loFile.Name, tcName, toInclude)
					If Not Empty (toInclude.File)
						llFound = .T.
						Exit
					Endif Not Empty (toInclude.File)
				Endif loFile.Type = 'P'
			Next loFile
		
			* Check all PRGs in the active project.
		
			For Each loFile In _vfp.ActiveProject.Files
				If Not llFound And loFile.Type = 'P'
					lcPRG = loFile.Name
					This.GoToDefProcessPRGForClass (lcPRG, tcName, toInclude, Upper (Filetostr (lcPRG)))
					If Not Empty (toInclude.File)
						llFound = .T.
						Exit
					Endif Not Empty (toInclude.File)
				Endif loFile.Type = 'P'
			Next loFile
		Endif Not llFound ...
		
		Return
		
	ENDPROC

	PROCEDURE gotodeffindconstant
		*** JIM: remove the second parameter and use "This" instead of toPEM everywhere it occurs
		Lparameters tcName
		
		*** Doug Hennig 2010-11-18
		* Get the include file for the form/class being edited.
		
		Local loInclude As 'Empty'
		Local laLines[1], lcFileName, lcInclude, lcIncludeFile, lcMethodCode, lcName, lcObjectFile, llFound
		Local lnCharPosition, lnI, lnLines
		
		* Create an object to hold return values.
		
		loInclude = Createobject ('Empty')
		AddProperty (loInclude, 'File', '')
		AddProperty (loInclude, 'CharPosition', 0)
		
		lcName		 = Upper (tcName)
		
		* Start with the current method.
		If This.IsPRGFile() or This.IsMethodCode()
			lcMethodCode = Upper (This.oEditorWin.Getstring(0, 10000000))
			This.GoToDefProcessInclude ('', lcMethodCode, lcName, loInclude)
		Endif
		
		If loInclude.CharPosition = 0
			lcInclude	 = This.GetCurrentIncludeFile()
			If File (lcInclude)
				This.GoToDefProcessInclude (lcInclude, Filetostr (lcInclude), lcName, loInclude)
			Endif
		Endif
		
		Return This.ShowMatchName(loInclude, lcName)
		
		
	ENDPROC

	PROCEDURE gotodeffindfile
		Lparameters lcFileName
		
		Local loFile As Object
		Local lcFullName
		
		If Empty(Justext(m.lcFileName))
			lcFileName = Forceext(m.lcFileName, '.SCX')
		Endif
		
		lcFullName = Fullpath (m.lcFileName)
		If File (m.lcFullName)
			This.EditSourceX (m.lcFullName)
			Return .T.
		Endif
		
		If Type ('_vfp.ActiveProject') = 'O'
			For Each m.loFile In _vfp.ActiveProject.Files
				lcFullName = m.loFile.Name
				If Lower(Justfname(m.lcFullName)) == Lower(Justfname(m.lcFileName))
					This.EditSourceX (m.lcFullName)
					Return .T.
				Endif
			Next m.loFile
		Endif
		
		Return .F.
		
	ENDPROC

	PROCEDURE gotodeffindprocedure
		*** JIM: remove the second parameter and use "This" instead of toPEM everywhere it occurs
		Lparameters tcName
		
		*** Doug Hennig 2010-11-18
		* Get the include file for the form/class being edited.
		
		Local loInclude As 'Empty'
		Local laLines[1], lcMethodCode, lcName
		
		* Create an object to hold return values.
		
		loInclude = Createobject ('Empty')
		AddProperty (m.loInclude, 'File', '')
		AddProperty (m.loInclude, 'CharPosition', 0)
		
		lcName		 = Upper (m.tcName)
		
		* This a PRG?  If so, there can be PROCs and FUNCs here
		If m.loInclude.CharPosition = 0 And This.IsPRGFile()
			lcMethodCode = Upper (This.oEditorWin.GetString(0, 10000000))
			This.GoToDefProcessPRG ('', m.lcName, m.loInclude, m.lcMethodCode)
		Endif
		
		If m.loInclude.CharPosition = 0
			This.GoToDefFindProgram (m.lcName, m.loInclude)
		Endif
		
		Return This.ShowMatchName(m.loInclude, m.lcName)
		
	ENDPROC

	PROCEDURE gotodeffindprogram
		Lparameters tcName, toInclude
		
		Local loFile As Object
		Local laLines[1], lcFile, lcFileName, lcProcedures, llFound, lnI, lnLines
		
		* All open procedure files.
		
		If Not m.llFound
			lcProcedures = Set ('Procedure')
			lcProcedures = Chrtran (m.lcProcedures, ['"], [ ])
			lnLines		 = Alines (laLines, m.lcProcedures, 5, ',')
			For lnI = 1 To m.lnLines
				If Not Empty (m.laLines[m.lnI])
					If Inlist(Upper(Justext(m.laLines[m.lnI])), 'PRG', 'FXP')
						lcFileName = Forceext(m.laLines[m.lnI], 'PRG')
						If File(m.lcFileName)
							This.GoToDefProcessPRG (m.lcFileName, m.tcName, m.toInclude)
							If Not Empty (m.toInclude.File)
								Exit
							Endif Not Empty (m.toInclude.File)
						Endif
					Endif
				Endif
			Next m.lnI
		Endif Not m.llFound
		
		* Check all PRGs in the active project. We may have to look in procedure files.
		
		If Not m.llFound And Type ('_vfp.ActiveProject') = 'O'
			For Each m.loFile In _vfp.ActiveProject.Files
				If m.loFile.Type = 'P'
					This.GoToDefProcessPRG (m.loFile.Name, m.tcName, m.toInclude)
					If Not Empty (m.toInclude.File)
						llFound = .T.
						Exit
					Endif Not Empty (m.toInclude.File)
				Endif m.loFile.Type = 'P'
			Next m.loFile
		Endif Not m.llFound ...
		
		
		* PRGs in the path.
		
		lcFile = m.tcName + '.PRG'
		If File (m.lcFile)
			toInclude.File = m.lcFile
			llFound		   = .T.
		Endif File (m.lcFile)
		
		
		Return
		
		
	ENDPROC

	PROCEDURE gotodeffindstem
		Lparameters tcStem, lcExtensions
		
		Local loFile As Object
		Local laExtensions[1], lcFName, lcFullName, lcStem, lnExtensions, lnI
		
		lcStem		 = Lower(m.tcStem)
		lnExtensions = Alines(laExtensions, Lower(m.lcExtensions), 5, ',')
		For lnI = 1 To m.lnExtensions
			lcFullName = Forceext(m.lcStem, m.laExtensions[m.lnI])
			If File (m.lcFullName)
				This.EditSourceX (m.lcFullName)
				Return .T.
			Endif
		Endfor
		
		If Type ('_vfp.ActiveProject') = 'O'
			For Each m.loFile In _vfp.ActiveProject.Files
				lcFullName = m.loFile.Name
				If Lower(Juststem(m.lcFullName)) == m.lcStem
					For lnI = 1 To m.lnExtensions
						lcFName = Forceext(m.lcStem, m.laExtensions[m.lnI])
						If Lower(Justfname(m.lcFullName)) == m.lcFName
							This.EditSourceX (m.lcFullName)
							Return .T.
						Endif
					Endfor
				Endif
			Next m.loFile
		Endif
		
		Return .F.
		
	ENDPROC

	PROCEDURE gotodefineclassparent
		Lparameters lcMethodName
		
		Local lcCLass, lcClassLib, lcCommand, lcFullName, lcQuote, lnEndPos, lnStartPos
		If Not Upper(m.lcMethodName) == 'DEFINE'
			Return .F.
		Endif
		
		lnStartPos = This.oEditorWin.GetLineStart (This.nLeftHighlightPos, 0)
		lnEndPos   = This.oEditorWin.GetLineStart (This.nLeftHighlightPos, 1)
		lcCommand  = This.oEditorWin.GetString (m.lnStartPos, m.lnEndPos - 1)
		lcCommand  = Chrtran(m.lcCommand, CRLF, '  ')
		
		lcCLass	   = Chrtran(Getwordnum(m.lcCommand, 5), ['"] + '[]', '')
		lcClassLib = ''
		If Upper(Getwordnum(m.lcCommand, 6)) == 'OF'
			lcClassLib = Getwordnum(m.lcCommand, 7)
			lcQuote	   = Left(m.lcClassLib, 1)
			If m.lcQuote $  ['"] + '['
				lcClassLib = Substr(m.lcCommand, Atc(m.lcClassLib, m.lcCommand))
				lcClassLib = Strextract(m.lcClassLib, m.lcQuote, Chrtran(m.lcQuote, '[', ']'))
			Endif
		
			lcFullName = Fullpath (m.lcClassLib)
			If File (m.lcFullName)
				This.EditSourceX (m.lcFullName, m.lcCLass)
				Return .T.
			Else
				Return .F.
			Endif
		Else
			Return This.GoToDefFindClass (m.lcCLass)
		Endif
		
	ENDPROC

	PROCEDURE gotodeflocal
		Local lcCLass, lcClassLib, lcCommand, lcFullName, lcQuote, lnEndPos, lnStartPos
		
		lnStartPos = This.oEditorWin.GetLineStart (This.nRightHighlightPos, 0)
		lnEndPos   = This.oEditorWin.GetLineStart (This.nRightHighlightPos, 1)
		lcCommand  = This.oEditorWin.GetString (m.lnStartPos, m.lnEndPos)
		
		lcCLass	   = Chrtran(Getwordnum(m.lcCommand, 4), ['"] + '[]', '')
		lcClassLib = ''
		
		If Upper(Getwordnum(m.lcCommand, 5)) == 'OF'
			lcClassLib = Getwordnum(m.lcCommand, 6)
			lcQuote	   = Left(m.lcClassLib, 1)
			If m.lcQuote $  ['"] + '['
				lcClassLib = Substr(m.lcCommand, Atc(m.lcClassLib, m.lcCommand))
				lcClassLib = Strextract(m.lcClassLib, m.lcQuote, Chrtran(m.lcQuote, '[', ']'))
			Endif
			lcFullName = Fullpath (m.lcClassLib)
			If File (m.lcFullName)
				This.EditSourceX (m.lcFullName, m.lcCLass)
				Return .T.
			Else
				Return .F.
			Endif
		
		Else
			Return This.GoToDefFindClass (m.lcCLass)
		Endif
		
	ENDPROC

	PROCEDURE gotodeflocateline
		Lparameters tcCode, tcName, tcPattern
		Local lnReturn, loMatches, loRegExp
		
		*** Doug Hennig 2010-11-18
		 
		* Create and set up a RegExp object.
		
		loRegExp = This.GetRegExp()
		With loRegExp
			*** JRN 2010-12-17 : Following pattern guarantees start of line
			.Pattern	= '^\s*' + tcPattern + '\s+' + tcName + '\b'
		EndWith 	
		
		* Try to find matches. Returns position of match (origin 1; 0 means no match)
		
		loMatches = loRegExp.Execute (tcCode)
		If loMatches.Count = 0
			lnReturn = 0
		Else
			lnReturn = loMatches.Item(0).FirstIndex + loMatches.Item(0).Length + 1 - Len(tcName)
		Endif loMatches.Count = 0
		
		Return lnReturn
		
	ENDPROC

	PROCEDURE gotodefnewobject
		Local laLines[1], lcClass, lcClassLib, lcFullName, lcText, llSuccess, lnCount, lnEndPos
		
		lnEndPos = This.oEditorWin.GetLineStart (This.nRightHighlightPos, 1)
		lcText	 = This.oEditorWin.GetString (This.nRightHighlightPos + 1, m.lnEndPos)
		
		llSuccess = .F.
		If '(' $ m.lcText
			lcText = Substr (m.lcText, 1 + At ('(', m.lcText))
		Endif
		
		If ')' $ m.lcText
			lcText = Left (m.lcText, At (')', m.lcText) - 1)
		Endif
		
		lnCount = Alines (laLines, m.lcText, .T., ',', ';')
		If m.lnCount > 0
			lcClass	   = This.RemoveQuotes (Alltrim (m.laLines(1)))
			If m.lnCount = 1
				llSuccess = This.GoToDefFindClass (m.lcClass)
			Else
				lcClassLib = This.RemoveQuotes (Alltrim (m.laLines(2)))
				If Not '.' $ m.lcClassLib
					lcClassLib = Forceext(m.lcClassLib, 'VCX')
				Endif
				lcFullName = Fullpath (m.lcClassLib)
				If File (m.lcFullName)
					This.EditSourceX (m.lcFullName, m.lcClass)
					llSuccess = .T.
				Endif
			Endif
		Endif
		
		Return m.llSuccess
	ENDPROC

	PROCEDURE gotodefprocessinclude
		Lparameters tcIncludeFileName, tcIncludeText, tcName, toInclude
		
		*** Doug Hennig 2010-11-18
		Local lcIncludeFile, lnCharPosition, lnI, loIncludeFiles
		
		lnCharPosition = This.GoToDefLocateLine (tcIncludeText, tcName, '#DEFI(|N|NE)')
		
		If lnCharPosition > 0
			toInclude.File		   = tcIncludeFileName
			toInclude.CharPosition = lnCharPosition
		Else
			loIncludeFiles = This.GetIncludeFiles (tcIncludeText)
			For Each lcIncludeFile In loIncludeFiles FoxObject
				If toInclude.CharPosition > 0
					Exit
				Endif toInclude.CharPosition > 0
		
				Do Case
					Case Empty(tcIncludeFileName)
						lcIncludeFile = Fullpath (lcIncludeFile)
					Case Upper(lcIncludeFile) = 'FOXPRO.H'
						lcIncludeFile = Addbs(Home()) + lcIncludeFile
					Otherwise
						lcIncludeFile = Fullpath (lcIncludeFile, tcIncludeFileName)
				Endcase
		
				If File (lcIncludeFile)
					This.GoToDefProcessInclude (lcIncludeFile, Filetostr (lcIncludeFile), tcName, toInclude)
				Endif
		
			Next lnI
		Endif
		
		Return
		
		
		
	ENDPROC

	PROCEDURE gotodefprocessprg
		Lparameters tcPRG, tcName, toInclude, tcCode
		
		*** Doug Hennig 2010-11-18
		
		* ================================================================================
		*** JRN 2022-12-04 : Use AProcInfo to narrow the search
		Local laProcs[1], lcCode, lnCharPosition, lnCount
		
		If not Empty(m.tcPRG)
			lnCount = Aprocinfo(laProcs, m.tcPRG)
			If m.lnCount = 0
				Return
			Endif
		
			If Ascan(m.laProcs, m.tcName, 1, -1, 1, 15) = 0
				Return
			Endif
		EndIf
		* ================================================================================
		
		If 'C' = Vartype(m.tcCode)
			lcCode = m.tcCode
		Else
			lcCode = Upper (Filetostr (m.tcPRG))
		Endif
		
		lnCharPosition = This.GoToDefLocateLine (m.lcCode, m.tcName, 'PROC(|E|ED|EDU|EDUR|EDURE)')
		If m.lnCharPosition = 0
			lnCharPosition = This.GoToDefLocateLine (m.lcCode, m.tcName, 'FUNC(|T|TI|TIO|TION)')
		Endif m.lnCharPosition = 0
		If m.lnCharPosition > 0
			toInclude.File		   = m.tcPRG
			toInclude.CharPosition = m.lnCharPosition
		Endif m.lnCharPosition > 0
		
		Return
		
	ENDPROC

	PROCEDURE gotodefprocessprgforclass
		Lparameters tcPRG, tcName, toInclude, tcCode
		
		*** JRN 2010-12-17 : 
		
		Local lnCharPosition
		
		* ================================================================================
		*** JRN 2022-12-04 : Use AProcInfo to narrow the search
		Local laProcs[1], lcCode, lnCharPosition, lnCount
		
		If not Empty(m.tcPRG)
			lnCount = Aprocinfo(laProcs, m.tcPRG, 1)
			If m.lnCount = 0
				Return
			Endif
		
			If Ascan(m.laProcs, m.tcName, 1, -1, 1, 15) = 0
				Return
			Endif
		EndIf
		* ================================================================================
		
		
		lnCharPosition = This.GoToDefLocateLine (tcCode, tcName, 'DEFI(|N|NE)\s+CLAS(|S)')
		If lnCharPosition > 0
			toInclude.File		   = tcPRG
			toInclude.CharPosition = lnCharPosition
		Endif lnCharPosition > 0
		
		Return
		
	ENDPROC

	PROCEDURE gotodefprocessvcxforclass
		Lparameters tcVCX, tcName, toInclude
		
		*** Doug Hennig 2010-11-18
		Local llOK, lnSelect
		lnSelect = Select()
		Select 0
		
		Try
			Use (tcVCX) Again Shared Alias This_VCX
			llOK = .T.
		Catch
			llOK = .F.
		Endtry
		
		If llOK
			Locate For (Lower (objname)) == Lower (tcName)		;
				And Lower(reserved1) = 'class' And Not Deleted()
			If Found()
				toInclude.File		   = tcVCX
			EndIf
			Use 
		Endif
		
		Select (lnSelect)
		Return
	ENDPROC

	PROCEDURE gotoisxclassdefinition
		Lparameters lcMethodName
		
		Local loCodeBlocks As Collection
		Local lcBlock, lcClass, lcClassLib, lcCode, lcDefineClass, lcExt, lcMethod, lcPRG, lcQuote, lnEnd
		Local lnI, lnStart, loBlock, loObject
		
		lcClass	   = ''
		lcClassLib = ''
		lcMethod   = ''
		
		If '.' $ m.lcMethodName
			loObject = Execscript(_Screen.cThorDispatcher, 'Thor_Proc_ISX', .F., .F., .F., .F., .F., .F., .T., Juststem(m.lcMethodName))
			If Vartype(m.loObject) = 'O' and PemStatus(loObject, 'Class', 5)
				lcClass	   = m.loObject.Class
				lcClassLib = m.loObject.ClassLibrary
				lcMethod   = Justext(m.lcMethodName)
			Endif
		Endif
		
		If Empty(m.lcClass)
			loObject = Execscript(_Screen.cThorDispatcher, 'Thor_Proc_ISX', .F., .F., .F., .F., .F., .F., .T., m.lcMethodName)
			If Vartype(m.loObject) = 'O' and PemStatus(loObject, 'Class', 5)
				lcClass	   = m.loObject.Class
				lcClassLib = m.loObject.ClassLibrary
			Endif
		Endif
		
		* These both are necessary else there is hanging reference preventing opening the file
		loObject			= Null
		_Screen.xThorResult	= Null
		
		lcExt	 = Upper(Justext(m.lcClassLib))
		
		Do Case
			Case Empty(m.lcClass)
				Return .F.
		
			Case m.lcExt == 'VCX'
				This.EditSourceX(m.lcClassLib, m.lcClass, m.lcMethod)
		
			Case m.lcExt == 'PRG' Or m.lcExt == 'FXP'
		
				Do While .T.
					lcPRG		 = Forceext(m.lcClassLib, 'PRG')
					If Not File(m.lcPRG)
						Return .F.
					Endif
		
					lcCode		  = Filetostr(m.lcPRG)
					loCodeBlocks  = Execscript (_Screen.cThorDispatcher, 'Thor_Proc_GetProcedureStartPositions.prg', m.lcCode, .T.)
					lcDefineClass = ''
		
					For lnI = 1 To m.loCodeBlocks.Count
						loBlock	  = m.loCodeBlocks.Item[m.lnI]
						Do Case
							Case Upper(m.loBlock.Name) == Upper(m.lcClass)
								lcDefineClass = Substr (m.lcCode, m.loBlock.Start, m.loBlock.Length)
								lnStart		  = m.loBlock.Start + Atc(m.lcClass, m.lcDefineClass) - 1
								lnEnd		  = m.lnStart + Len(m.lcClass)
		
								If Empty(m.lcMethod)
									This.EditSourceX(m.lcPRG, , , m.lnStart, m.lnEnd)
									Execscript(_Screen.cThorDispatcher, 'Thor_Proc_SelectText')
									Return .T.
								Endif
		
							Case Upper(m.loBlock.Name) == Upper(m.lcClass + '.' + m.lcMethod)
								lcBlock	= Substr (m.lcCode, m.loBlock.Start, m.loBlock.Length)
								lnStart	= m.loBlock.Start + Atc(m.lcMethod, m.lcBlock) - 1
								lnEnd	= m.lnStart + Len(m.lcMethod)
		
								This.EditSourceX(m.lcPRG, , , m.lnStart, m.lnEnd)
								Execscript(_Screen.cThorDispatcher, 'Thor_Proc_SelectText')
		
								Return .T.
		
						Endcase
					Endfor
		
					* -------------------------------------------------------------------------------- 
					* OK, let's try the parent class
					If Empty(m.lcDefineClass)
						Return .F.
					Endif
		
					lcClass	   = Chrtran(Getwordnum(m.lcDefineClass, 5), ['"] + '[]', '')
					lcClass	   = Chrtran(m.lcClass, CRLF, '')
					lcClassLib = ''
					If Upper(Getwordnum(m.lcDefineClass, 6)) == 'OF'
						lcClassLib = Getwordnum(m.lcDefineClass, 7)
						lcClassLib = Chrtran(m.lcClassLib, CRLF, '')
						lcQuote	   = Left(m.lcClassLib, 1)
						If m.lcQuote $  ['"] + '['
							lcClassLib = Substr(m.lcDefineClass, Atc(m.lcClassLib, m.lcDefineClass))
							lcClassLib = Strextract(m.lcClassLib, m.lcQuote, Chrtran(m.lcQuote, '[', ']'))
						Endif
					Endif
		
					Try
						loObject = Newobject(m.lcClass, m.lcClassLib, 0)
					Catch
					Endtry
		
					If Isnull(m.loObject)
						Return .F.
					Endif
		
					lcClassLib = m.loObject.ClassLibrary
					loObject   = Null
		
				Enddo
		
				Return .F.
		
		Endcase
	ENDPROC

	PROCEDURE handleexistingobject
		Local lcObjectName, loExplorer
		
		lcObjectName = This.cMethodName
		
		If m.lcObjectName == Chrtran(m.lcObjectName, ':\ ', '')
		
			Do Case
					* ignore these two special cases
				Case 'THIS' == Upper(m.lcObjectName) or 'THISFORM' == Upper(m.lcObjectName)
					This.lFound	   = .F.
					This.lSearched = .F.
		
					* pointing to name of an existing object
				Case (Not '.' $ m.lcObjectName) and 'O' = Type(m.lcObjectName) And 'O' = Vartype(&lcObjectName)
					Execscript(_Screen.cThorDispatcher, 'Thor_Tool_ObjectExplorer', &lcObjectName)
					This.lFound	   = .T.
					This.lSearched = .T.
		
					* or the name of an object obtained through aliasing
				Case This.GetAliasObject()
					This.lFound	   = .T.
					This.lSearched = .T.
		
			Endcase
		
		Endif && m.lcObjectName == Chrtran(m.lcObjectName, ':.\ ', '')
		
		Return This.lSearched
		
	ENDPROC

	PROCEDURE handlefilenames
		Lparameters loTopOfForm
		
		Do Case
		
				* file name in quotes (assumes SCX if no extension)
			Case Left(This.cMethodName, 1) $  ['"] + '['
				This.lFound	   = This.GoToDefFindFile (This.RemoveQuotes (This.cMethodName))
				This.lSearched = .T.
		
				* looks like file name due to embedded characters (assumes SCX if no extension)
			Case CR $ Chrtran(This.cMethodName, ' :\', CR + CR + CR)
				This.lFound	   = This.GoToDefFindFile (This.cMethodName)
				This.lSearched = .T.
		
				* File names with extensions (only one dot)
			Case 1 = Occurs('.', This.cMethodName)					;
					And Len(Justext(This.cMethodName)) <= 4			;
					And This.GoToDefFindFile (This.cMethodName)
				This.lFound	   = .T.
				This.lSearched = .T.
		
				* File Name with extension
			Case Not Empty(Justext(This.cFullMethodName)) And This.GoToDefFindFile (This.cFullMethodName)
				This.lFound	   = .T.
				This.lSearched = .T.
		
			Case Not Empty(Justext(This.cFullMethodName))
		
				* File Name, no extension, look for PRG
			Case This.GoToDefFindStem (This.cMethodName, 'PRG, SCX, VCX, FRX')
				This.lFound	   = .T.
				This.lSearched = .T.
		
		Endcase
		
		Return This.lSearched
		
	ENDPROC

	PROCEDURE handlekeywords
		Lparameters loTopOfForm
		
		Local lcText, lnStartPos
		
		Do Case
		
				* NEWOBJECT
			Case Upper (This.cMethodName) == 'NEWOBJECT'
				This.lFound	   = This.GoToDefNewObject ()
				This.lSearched = .T.
		
				* CREATEOBJECT
			Case Upper (This.cMethodName) == 'CREATEOBJECT'
				This.lFound	   = This.GoToDefCreateObject ()
				This.lSearched = .T.
		
				* LOCAL
			Case Upper (This.cMethodName) == 'LOCAL'
				This.lFound	   = This.GoToDefLocal ()
				This.lSearched = .T.
		
				* Define class NAME as class of classlib
			Case This.GoToDefineClassParent (This.cMethodName)
				This.lFound	   = .T.
				This.lSearched = .T.
		
				* Class definition in curly braces !!! needs research and examples
			Case This.GoToDefCurlyBraces (This.cMethodName)
				This.lFound	   = .T.
				This.lSearched = .T.
		
				* DO FORM and REPORT FORM
			Otherwise
				
				*!* ******** JRN Removed 2023-02-02 ********
				*!* lcText = This.GetEntireLine(This.nLeftHighlightPos)
		
				*!* Do Case
				*!* 	Case Getwordcount (m.lcText) # 2
		
				*!* 	Case Upper (Getwordnum (m.lcText, 1)) == 'DO'		;
				*!* 			And Upper (Getwordnum (m.lcText, 2)) == 'FORM'
				*!* 		This.lFound	   = This.GoToDefFindFile (Forceext (This.cMethodName, 'SCX'))
				*!* 		This.lSearched = This.lFound
				*!* 	Case Upper (Getwordnum (m.lcText, 1)) == 'REPORT'		;
				*!* 			And Upper (Getwordnum (m.lcText, 2)) == 'FORM'
				*!* 		This.lFound	   = This.GoToDefFindFile (Forceext (This.cMethodName, 'FRX'))
				*!* 		This.lSearched = This.lFound
				*!* Endcase
		
		Endcase
		
		Return This.lSearched
	ENDPROC

	PROCEDURE handleopenedfilename
		Local lcAlias
		
		lcAlias = Execscript (_Screen.cThorDispatcher, 'PEME_OpenTable', This.cMethodName)
		
		If Not Empty(m.lcAlias)
			This.BrowseTable(m.lcAlias)
			Return .T.
		Else
			Return .F.
		Endif
		
		
		
	ENDPROC

	PROCEDURE handlethisform
		Lparameters loTopOfForm
		
		Local laObjects[1], lcMethod, lcObjectName, llAnySelectedObjects, lnNextDot
		
		If Upper (This.cMethodName) == 'THIS'
			This.cMethodName = 'THIS.'
		EndIf
		
		This.SetupDODEFAULT()
		
		Do Case
		
			Case This.cMethodName = '.' && not clear if this is needed any more
		
			Case Upper(This.cFullMethodName) = 'THISFORM' And Upper(m.loTopOfForm.BaseClass) # 'FORM'
				This.lSearched = .T.
				This.lFound	   = .F.
				Return .T.
		
			Case Upper (This.cMethodName) == 'THISFORM'
				This.lFound	   = This.GoToDef (m.loTopOfForm, '', '', m.loTopOfForm, This.lDoDefault)
				This.lSearched = .T.
		
			Case Upper (This.cMethodName) = 'THISFORM.'
				This.cMethodName = Substr (This.cMethodName, 9)
		
			Case Upper (This.cMethodName) = 'THIS.'
		
				If Upper (This.cMethodName) == 'THIS.'
					lcMethod = ''
				Else
					lcMethod = Substr (This.cMethodName, 5)
				Endif
		
				llAnySelectedObjects = 0 # Aselobj (laObjects) Or 0 # Aselobj (laObjects, 1)
		
				Do Case
					Case Isnull (m.loTopOfForm)
		
					Case This.lFullPath && we got the full path already (parens indicated timestamp)
						This.cMethodName = Left (This.cWonTop, Rat ('.', This.cWonTop) - 1) + m.lcMethod
					Case This.cWonTop = Upper (m.laObjects(1).Name + '.') && matches current object?
						This.cMethodName = This.GetObjectPath (m.laObjects(1)) + m.lcMethod
					Otherwise
						This.cMethodName = Left (This.cWonTop, At ('.', This.cWonTop) - 1) + m.lcMethod
				Endcase
				If Empty(This.cMethodName)
					This.lFound	   = This.GoToDef (m.loTopOfForm, '', '', m.loTopOfForm, This.lDoDefault)
					This.lSearched = .T.
				Endif
		
			Case '.' $ This.cMethodName && must be something like loObject.<Reference> ... remove loObject
				lnNextDot		 = At ('.', This.cMethodName)
				This.cMethodName = Substr (This.cMethodName, m.lnNextDot)
		
			Otherwise
				Return .F.
		Endcase
		
		If Not This.lSearched
			If  '.' $ This.cMethodName
				lcObjectName = Upper (Juststem (This.cMethodName))
				If m.lcObjectName # '.' And Not Empty (m.lcObjectName)
					lcObjectName = '.' + m.lcObjectName
				Endif
				lcMethod	= Justext (This.cMethodName)
				This.lFound	= This.GoToDef (m.loTopOfForm, m.lcObjectName, m.lcMethod, m.loTopOfForm, This.lDoDefault)
			Else
				This.lFound = This.GoToDef (m.loTopOfForm, '', This.cMethodName, m.loTopOfForm, This.lDoDefault)
			Endif
		Endif
		
		If Not This.lFound
			If 1 = Occurs('.', This.cFullMethodName)		;
					And This.cMethodName = '.'				;
					And Inlist(Upper(Juststem(This.cFullMethodName)) + '.', 'THIS.', 'THISFORM.')
				This.DoFormAddPEM(Substr(This.cMethodName, 2), .T., '', .F., '')
				This.lFound = .T.
			Endif
		Endif
		
		Return .T.
		
	ENDPROC

	PROCEDURE handlethisinprg
		Local llFound, lxResult
		
		llFound = .F.
		If This.IsPRGFile() And Upper (This.cMethodName) = 'THIS.'
			lxResult = Execscript(_Screen.cThorDispatcher, 'Thor_Proc_PEME_GoToDefPRGXClasses', This.cMethodName)
			llFound	 = (Not Isnull(m.lxResult)) And m.lxResult
		Endif
		
		This.lSearched = m.llFound
		Return m.llFound
		
	ENDPROC

	PROCEDURE Init
		With This
		
			.oEditorWin = Execscript(_Screen.cThorDispatcher, 'Thor_Proc_EditorWin')
		
		Endwith
		
		
		
	ENDPROC

	PROCEDURE ismenucode
		Return This.nWindowType = MenuCode
	ENDPROC

	PROCEDURE ismethodcode
		Return This.nWindowType = MethodCode
	ENDPROC

	PROCEDURE isprgfile
		Return This.nWindowType = PRGFile
	ENDPROC

	PROCEDURE isreadonly
		Lparameters loObject, lcPem
		
		Local lbResult
		
		Try
			lbResult = This.GetPEMStatus ( loObject, lcPem, 1 )
		Catch
			lbResult = .F.
		Endtry
		
		Return lbResult
		
	ENDPROC

	PROCEDURE movewindow
		Local laDims[1], laEnv[25], lcTitle, lnCount, lnHandle, lnHeight, lnLeft, lnResult, lnTop, lnWidth
		Local loEditorWin
		
		* Get the whandle for the current window
		loEditorWin = This.oEditorWin
		lxResult = loEditorWin.FindWindow()
		
		If lxResult = -1
			Return
		EndIf
		
		If Not (This.IsPRGFile() or This.IsMethodCode())
			Return
		Endif
		
		lnCount = Alines (laDims, This.oPrefs.cWindowDimensions, .T., ',')
		
		If lnCount >= 1 And Not Empty (laDims(1))
			lnLeft = Val (laDims(1))
		Else
			lnLeft = loEditorWin.GetLeft()
		Endif
		
		If lnCount >= 2 And Not Empty (laDims(2))
			lnTop = Val (laDims(2))
		Else
			lnTop = loEditorWin.GetTop()
		Endif
		
		If lnCount >= 3 And Not Empty (laDims(3))
			lnWidth = Val (laDims(3))
		Else
			lnWidth = loEditorWin.GetWidth()
		Endif
		lnWidth = Max(100, Min(lnWidth, _Screen.Width - lnLeft)) 
		
		If lnCount >= 4 And Not Empty (laDims(4))
			lnHeight = Val (laDims(4))
		Else
			lnHeight = loEditorWin.GetHeight()
		Endif
		lnHeight = Max(100, Min(lnHeight, _Screen.Height - lnTop)) 
		
		loEditorWin.MoveWindow (lnLeft, lnTop)
		loEditorWin.ReSizeWindow (lnWidth, lnHeight)
		
	ENDPROC

	PROCEDURE peme_findtopmostparent
		* Find the top-most parent object for the specified object. The complication is
		* that the top level container is a Formset in the Form and Class Designers,
		* and even worse, one level down from the Formset is a Form for non-form
		* classes in the Class Designer. So, we need to be careful about finding the
		* top-most parent object.
		
		* Unfortunately, there's no way to distinguish between a FormSet and a Form
		* open in the Form Designer. In both cases, the FormSet is a baseclass. So,
		* this code just returns a reference to the form.
		
		Lparameters toObject,		;
			tlClass
		Local llClass, loObject1, loObject2
		
		* Determine if we're in the Class or Form Designer.
		
		llClass = IIf (Pcount() = 1, Upper (Wontop()) = 'CLASS DESIGNER', tlClass)
		Store toObject To loObject1, loObject2
		
		* Go up the containership hierarchy until we hit a form.
		
		Do While Type ('loObject1.Parent.Name') = 'C' And			;
				Not Upper (loObject1.BaseClass) == 'FORM' And		;
				Not Upper (loObject1.BaseClass) == 'TOOLBAR'
		
			loObject2 = loObject1
			loObject1 = loObject1.Parent
		Enddo While Type ('loObject1.Parent.Name') = 'C' ...
		Do Case
		
				* If the form's parent is a non-baseclass FormSet, we're modifying a FormSet in
				* the Class Designer, return a reference to the formset.
		
			Case Upper (loObject2.BaseClass) == 'FORMSET'
		
			Case Upper (loObject1.Parent.BaseClass) == 'FORMSET' And		;
					Not Empty (loObject1.Parent.ClassLibrary)
				loObject2 = loObject1.Parent
		
				*** JRN 2009-09-26 : Courtesy of Burkhart Stiller 
				* for a SCX based formset, the form does not have 'BufferMode'
			Case (Not llClass) And Upper (loObject1.Parent.BaseClass) == 'FORMSET'		;
					And Not This.GetPEMStatus (loObject1, 'BufferMode', 5)
				loObject2 = loObject1.Parent
		
				* If the form is a baseclass Form and we're in the Class Designer, we're
				* modifying a non-form class, so already have the correct object reference.
		
			Case llClass And Upper (loObject1.Class) == 'FORM'
		
				* For all other cases (a form class open in the Class Designer or a form open
				* in the Form Designer), return a reference to the form.
		
			Otherwise
				loObject2 = loObject1
		Endcase
		
		Return loObject2
		
	ENDPROC

	PROCEDURE quickaddpem
		Lparameters llOnlyIfFormOrClass
		
		Local loForm As Object
		Local laObjects[1], lcFile, lnI, loTools
		
		If m.llOnlyIfFormOrClass And 0 = Aselobj(laObjects) And 0 = Aselobj(laObjects, 1)
			Return
		Endif
		
		For lnI = 1 To _Screen.FormCount
			loForm = _Screen.Forms[m.lnI]
			If Pemstatus(m.loForm, 'lAskAddPEM', 5) And m.loForm.lAskAddPEM
				m.loForm.Show()
				loForm = .Null.
				Return
			Endif
		Endfor
		loForm	= .Null.
		
		*** JRN 2023-01-30 : Form to add PEMs in same folder as this class
		loTools	= Execscript (_Screen.cThorDispatcher, 'Class= tools from pemeditor')
		If Isnull(m.loTools)
			Return
		Endif
		lcFile = Forcepath('AskAddPEMNewStayOpen.SCX', Justpath(m.loTools.ClassLibrary))
		If File(m.lcFile)
			Do Form (m.lcFile) With, .T., , .T.
		Endif
		
	ENDPROC

	PROCEDURE readme
		#if .F.
		
		Thor Procs, referenced by    	Execscript (_Screen.cThorDispatcher, ...)
		
		Thor_Proc_EditorWin				ToolBox for handling windows and their contents in IDE
		Thor_Proc_SelectText			Highlights text in a code window and moves that line to the top of the window;
											if no parameters supplied, moves current line to the top of the window.
		Thor_Proc_SuperBrowse			Call SuperBrowse
		Thor_Proc_AddPEM.SCX			Open form to add new property or method (from PEMEditor)
		Thor_Proc_GetThorTableAlias 	Maps an alias to its "Real Name" in Thor's TableAliases Table
		Thor_Proc_ISX_GetNewObject  	Get an object from the value of an alias in Thor's TableAliases Table
		Thor_Proc_GetProcedureStartPositions	Get an object of the start and end positions of all methods in a PRG class
		Thor_Proc_FrmExplorer.scx		Open Object Explorer
		Thor_Proc_ISX					Use the guts of IntellisenseX to find an object definition
		Thor_Proc_PEME_GoToDefPRGXClasses		For PRG based classes, find and go to a method
		
		#endif 
	ENDPROC

	PROCEDURE removequotes
		Lparameters lcText
		
		Local lcEnds
		
		lcEnds	 = Left (lcText, 1) + Right (lcText, 1)
		If Len (lcText) > 2 And Inlist (lcEnds, [''], [""], '[]')
			Return Substr (lcText, 2, Len (lcText) - 2)
		Else
			Return ''
		Endif
		
	ENDPROC

	PROCEDURE run		&& Occurs when an Active Document is ready to execute your application code.
		Local laObjects[1], llDone, llFailed, loTopOfForm
		
		* ================================================================================
		#Define clShowTimings .F.
		#If clShowTimings
			#Define ccRecordTimings This.Timing() And
		#Else
			#Define ccRecordTimings
		#Endif
		* ================================================================================
		
		This.nWindowType = This.oEditorWin.FindWindow()
		
		*** JRN 2022-11-27 : if not in a code window, possibly add new PEM
		If This.nWindowType < 0
			This.QuickAddPEM(.T.)
			Return ''
		Endif
		
		* ================================================================================ 
		*** JRN 2022-11-28 : Setup
		With This
			.lFound		  = .F.
			.lSearched	  = .F.
			.lFormOrClass = .nWindowType = MethodCode
			If This.lFormOrClass
				loTopOfForm	= .FindTopMostParent()
				This.SetupDODEFAULT()
			Endif
		
			.cMethodName	 = .GetCurrentHighlightedText (.T., .T.)
			.cFullMethodName = .cMethodName
		
			.cWonTop	= .oEditorWin.GetTitle()
			.lFullPath	= .F.
			.lDoDefault	= .F.
		Endwith
		
		This.GetWindowName()
		
		* ================================================================================ 
		
		Do Case
		
				* This is a NO OP
			Case ccRecordTimings Right(This.cMethodName, 1) = '.'
		
				* can be empty if trying to add a method with parameters ... ThisForm.SomeNewMethod(parameters)
			Case ccRecordTimings Empty(This.cMethodName)
				If This.AddMethodWithParameters() = .F.
					This.QuickAddPEM(.T.)
				Endif
				This.lFound	   = .T.
				This.lSearched = .T.
		
				* if the name of an open alias
			Case ccRecordTimings Used(This.cMethodName)
				This.BrowseTable(This.cMethodName)
				This.lFound	   = .T.
				This.lSearched = .T.
		
				* if the name of an existing object
			Case ccRecordTimings This.HandleExistingObject()
		
				* NEWOBJECT, LOCAL, DO FORM, etc
			Case ccRecordTimings This.HandleKeywords(m.loTopOfForm)
		
				* actually, both THIS and THISFORM
			Case ccRecordTimings This.lFormOrClass And This.HandleTHISFORM(m.loTopOfForm)
		
				* THISDot in PRG classes
			Case ccRecordTimings This.HandleTHISinPRG()
		
				* file names (full path, etc)
			Case ccRecordTimings This.HandleFileNames()
		
				* if the name of an alias that can be opened
			Case ccRecordTimings This.HandleOpenedFileName()
				This.lFound	   = .T.
				This.lSearched = .T.
		
				* if the name of one of Thor's Tools or Procs
			Case ccRecordTimings Lower(This.cMethodName) = 'thor_' And Not Isnull(Execscript(_Screen.cThorDispatcher, 'Edit=' + This.cMethodName))
				This.lFound	   = .T.
				This.lSearched = .T.
		
				* Find defined constants
			Case ccRecordTimings This.GoToDefFindConstant (This.cMethodName)
				This.lFound	   = .T.
				This.lSearched = .T.
		
				* ================================================================================
				*	Remainder of these are slower
				* ================================================================================
		
				* Find procedure names in PRGs 
			Case ccRecordTimings This.GoToDefFindProcedure(This.cMethodName)
				This.lFound	   = .T.
				This.lSearched = .T.
		
				* Class Name
			Case ccRecordTimings (Not '.' $ This.cMethodName)  And This.GoToDefFindClass(This.cMethodName)
		
				* Find any the special things that IntellisenseX can handle with dropdowns
			Case ccRecordTimings This.GoToISXClassDefinition(This.cFullMethodName)
				This.lFound	   = .T.
				This.lSearched = .T.
		
			Otherwise 
				llFailed = ccRecordTimings .T.
				Messagebox (Strtran (ccLOC_Cap_DefNotFound, '<insert>', This.cFullMethodName), 16, ccLOC_Title_DefNotFound, cnMB_TimeOut)
		
		Endcase
		
		llDone = ccRecordTimings .T.
		
		*** JRN 2022-12-05 : Bookmark where we end
		If This.lFound
			Execscript (_Screen.cThorDispatcher, 'THOR_Proc_ManageBookmark', 'Add')
		Endif
	ENDPROC

	PROCEDURE setupdodefault
		*** JRN 2010-04-03 : Handling for DoDefault
		If Upper (This.cMethodName) = 'DODEFAULT'
			This.cMethodName = This.cWonTop
			This.lDoDefault	 = .T.
			If Not '(' $ This.cMethodName
				This.cMethodName = 'This.' + Justext(This.cMethodName)
			Endif
		Else
			This.lDoDefault = .F.
		Endif
		
		
	ENDPROC

	PROCEDURE setupforparentobjectclasses
		Lparameters lcClass, lcClassLib, loObject, loTopOfForm
		Local loResult AS 'Empty'
		Local lcBaseClass, lcClassName, lcParent 
		
		loResult = Createobject ('Empty')
		
		lcBaseClass = loObject.BaseClass
		Do While .T.
		
			Do Case
				Case loObject = loTopOfForm
					Exit && obviously at top of class/form
				Case This.Isreadonly (loObject, 'Name')
					* if name is read-only, continue -- must be part of parent class
				Case Inlist (Lower (loObject.BaseClass) + '#', 'page#', 'column#', 'optionbutton#', 'header#')
					* any of these baseclasses must be part of parent class ... #'s because of pageframe match
				Otherwise && for all others, we must be done
					Exit
			Endcase
		
			lcParent   = loObject.Parent.Name + IIf ( Empty (lcParent), '', '.' + lcParent)
			loObject   = loObject.Parent
			lcClassLib = loObject.ClassLibrary
			lcBaseClass = loObject.BaseClass
		Enddo
		
		lcClassName = loObject.Class
		
		Do Case
			Case Empty (lcParent)
		
			Case Not '.' $ lcParent
				lcParent = lcClassName
		
			Otherwise
				lcParent = lcClassName  + Substr (lcParent, At ('.', lcParent))
		
		Endcase
		
		AddProperty (loResult, 'Class', 	lcClass)
		AddProperty (loResult, 'ClassLib', 	lcClassLib)
		AddProperty (loResult, 'Parent', 	lcParent)
		AddProperty (loResult, 'BaseClass',	lcBaseClass)
		
		Return loResult
		
	ENDPROC

	PROCEDURE showmatchname
		Lparameters loInclude, lcName
		
		Local lcFileName, llFound, lnCharPosition
		
		lcFileName	   = m.loInclude.File
		lnCharPosition = m.loInclude.CharPosition
		
		Do Case
		
			Case Empty (m.lcFileName) And Empty (m.lnCharPosition)
				llFound = .F.
		
			Case Empty (m.lcFileName)
				llFound = .T.
				Execscript(_Screen.cThorDispatcher, 'THOR_PROC_SelectText', m.lnCharPosition - 1, m.lnCharPosition + Len (lcName) - 1)
		
				*!* ******************** Removed 11/29/13 *****************
				*!* With This.oEditorWin
				*!* 	.Select (lnCharPosition - 1, lnCharPosition + Len (lcName) - 1)
				*!* 	.ShowPosition()
				*!* Endwith
		
			Case Empty (m.lnCharPosition)
				llFound = .T.
				This.EditSourceX (m.lcFileName)
				This.MoveWindow()
		
			Otherwise
				llFound = .T.
				This.EditSourceX (m.lcFileName, , , m.lnCharPosition, m.lnCharPosition + Len (lcName))
				Execscript(_Screen.cThorDispatcher, 'THOR_PROC_SelectText', m.lnCharPosition - 1, m.lnCharPosition + Len (lcName) - 1)
				This.MoveWindow()
		Endcase
		
		Return m.llFound
		
	ENDPROC

	PROCEDURE timing
		Local laStack[1], lnCount
		
		If This.NSeconds # 0
			? Str(Seconds() - This.NSeconds, 6, 2), '  ' + This.cStackLine
		Endif
		
		lnCount			= Astackinfo(laStack)
		This.cStackLine	= Alltrim(Strtran(m.laStack[m.lnCount - 1, 6], 'ccRecordTimings ', '', 1, 1), 1, ' ', Tab)
		This.NSeconds	= Seconds()
		
	ENDPROC

ENDDEFINE
